---
title: "Módulos: Procedimentos e funções"
subtitle: "Algoritmos e Estruturas de Dados"
author: "Prof. Darlon Vasata"
bibliography: references.bib
csl: abnt.csl

format:
  revealjs:
    smaller: true

  beamer:
    fontsize: "8pt"
---

# Decomposição

Uma das grandes dificuldades presentes no desenvolvimento de algoritmos é como lidar com a complexidade dos problemas. Problemas grandes ou repetitivos podem ser decompostos em pequenos problemas, com partes exclusivas para a resolução de determinadas partes do problema.

A decomposição de códigos implica na construção de módulos, que podem ser chamados durante a execução do algoritmo.

# Modularização

A construção de um **módulo** trata do desenvolvimento de um sub-algoritmo, este especializado em resolver determinado problema. É como se refinássemos um problema, e a partir das pequenas soluções chegássemos a uma solução final para todo o problema. Outra vantagem da modularização é a **reutilização de código**, dado que quando o mesmo sub-problema aparece diversas vezes, não é necessário reescrever a solução para o sub-problema diversas vezes, assim reaproveitando soluções já desenvolvidas.

É comum a categorização de módulos em **procedimentos** e **funções**. Nos procedimentos, há a mera execução de trechos de código, enquanto nas funções um valor é **retornado** na linha de código que executou a chamada à determinada função.

É uma boa prática utilizar **verbos no infinitivo** nos nomes das funções e procedimentos, denotando as ações que são realizadas no módulo. Exemplos: somarValores, calcularMedia, preencherFormulario, apresentarValores, lerInteiro, lerReal, entradaAbrir, entradaFechar, etc.



## Procedimentos

Um procedimento é um conjunto de linhas de um algoritmo que são agrupados, e quando o procedimento é chamado, todas as linhas são executadas.

**Exemplo**  
Tome como exemplo um sistema em que no início do algoritmo é mostrado um cabeçalho e ao final é mostrado um rodapé, estes compostos por uma sequência de `"="`. O algoritmo consiste em perguntar o nome do usuário e apresentar seu nome na tela, junto com a mensagem "Boa noite".

Uma forma de solução para o problema seria:

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

``` c
inicio

//variaveis
caractere nome;

//cabecalho
// highlight-next-line
escreva("==========");

//Entrada e saída
escreva("Nome: ");
leia(nome);
escreva("Boa noite ", nome);

//rodapé
// highlight-next-line
escreva("==========");

fim.
```

  </TabItem>
  <TabItem value="java" label="Java">

``` javascript
pubic static void Main(String[] args){

    //variáveis
    String nome;
    Scanner entrada = new Scanner(System.in);

    // highlight-next-line
    System.out.println("##########");

    //entrada e saída
    System.out.println("Nome: ");
    nome = entrada.next();
    System.out.printf("Boa noite, %s\n", nome);

    // highlight-next-line
    System.out.println("##########");

    scanner.close();
}
```

  </TabItem>
  <TabItem value="python" label="Python">

``` python
# highlight-next-line
print("##########")
nome = input("Nome: ")
print(f"Boa noite, {nome}")
# highlight-next-line
print("##########")

```

  </TabItem>
</Tabs>

No exemplo observe que há linha que se repete. Esta linha (ou mais que uma linha) poderia ser parte de um procedimento.

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

``` c
inicio
    //módulos
    // highlight-start
    modulo linhas
        escreva("==========")
    fimmodulo.
    // highlight-end

    //variaveis
    caractere nome;

    //cabecalho
    // highlight-next-line
    linhas();   

    //Entrada e saída
    escreva("Nome: ");
    leia(nome);
    escreva("Boa noite ", nome);

    //rodapé
    // highlight-next-line
    linhas();
fim.
```

  </TabItem>
  <TabItem value="java" label="Java">

``` javascript

// highlight-start
public static void linhas(){
    System.out.println("##########");
}
// highlight-end

pubic static void Main(String[] args){

    //variáveis
    String nome;
    Scanner entrada = new Scanner(System.in);

    // highlight-next-line
    linhas();

    //entrada e saída
    System.out.println("Nome: ");
    nome = entrada.next();
    System.out.printf("Boa noite, %s\n", nome);

    // highlight-next-line
    linhas();

    scanner.close();
}

```

  </TabItem>
  <TabItem value="python" label="Python">

``` python

def linhas():
    print("##########")

linhas()
nome = input("Nome: ")
print(f"Boa noite, {nome}")
linhas()

```

  </TabItem>
</Tabs>

**Atividade**
- O que deveria ser feito para modificar o cabeçalho, utilizando `*`?
    - É necessário realizar esta modificação em quantas linhas?

:::info

As principais vantagens da modularização são:
- O mesmo trecho de código pode ser executado mais de uma vez, diminuindo a quantidade de código escrito;
- Caso seja necessário atualizar esse trecho de código, este é modificado em apenas um lugar, a atualização será válida para todo o algoritmo;
- O teste de código fica mais simplificado, dado que é possível testar trechos de código;

:::

## Funções

Os procedimentos consistem na mera execução das linhas de código que estão contidas neles. Já as funções podem **retornar** um valor, ou seja, trazer um valor que foi calculado ou obtido dentro delas para dentro do algoritmo.

**Exemplo**  

Considere um algoritmo que pergunta a três pessoas sua idade, calcula e *retorna* a idade média entre essas pessoas:

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ``` c
  inicio
    //variáveis
    inteiro idade_p1, idade_p2, idade_p3;
    real idade_media;

    //entrada
    escreva("Idade da primeira pessoa: ");
    leia(idade_p1);
    escreva("Idade da segunda pessoa: ");
    leia(idade_p2);
    escreva("Idade da terceira pessoa: ");
    leia(idade_p3);

    //processamento
    idade_media = (idade_p1 + idade_p2 + idade_p3)/3;

    //saida
    escreva("A idade média é ", idade_media);

  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ``` javascript
public static void main(String[] args){
    
    //variáveis
    int idade_p1, idade_p2, idade_p3;
    real idade_media;
    Scanner entrada = new Scanner(System.in);

    //entrada
    System.out.println("Idade da primeira pessoa: ");
    idade_p1 = entrada.nextInt();
    System.out.println("Idade da segunda pessoa: ");
    idade_p2 = entrada.nextInt();
    System.out.println("Idade da terceira pessoa: ");
    idade_p3 = entrada.nextInt();

    //processamento
    idade_media = (idade_p1 + idade_p2 + idade_p3)/3;

    //saida
    System.out.printf("A idade média é %f\n", idade_media);
}
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
  idade_p1 = int(input("Idade da primeira pessoa: "))
  idade_p2 = int(input("Idade da segunda pessoa: "))
  idade_p3 = int(input("Idade da terceira pessoa: "))

 idade_media = (idade_p1 + idade_p2 + idade_p3)/3

 print(f"A idade média é de {idade_media}")
  ```

  </TabItem>
</Tabs>

Poderia ser desenvolvida uma função que obtém as entradas e calcula e retorna a idade média.

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ``` c
  inicio
    modulo idadeMediaTresPessoas
        //variáveis
        inteiro idade_p1, idade_p2, idade_p3;
        real media_idade;

        //entrada
        escreva("Idade da primeira pessoa: ");
        leia(idade_p1);
        escreva("Idade da segunda pessoa: ");
        leia(idade_p2);
        escreva("Idade da terceira pessoa: ");
        leia(idade_p3);

        //processamento
        media_idade ← (idade_p1 + idade_p2 + idade_p3)/3;

        //retorno do valor calculado
        // highlight-next-line
        retorne(media_idade);

    fimmodulo.

    //variáveis
    real idade_media;

    //chamada ao módulo
    // highlight-next-line
    idade_media ← idadeMediaTresPessoas();

    //saida
    escreva("A idade média é ", idade_media);

  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ``` javascript
static Scanner entrada = new Scanner(System.in);

public static void idadeMediaTresPessoas(){
    //variáveis
    int idade_p1, idade_p2, idade_p3;
    real media_idade;
    
    //entrada
    System.out.println("Idade da primeira pessoa: ");
    idade_p1 = entrada.nextInt();
    System.out.println("Idade da segunda pessoa: ");
    idade_p2 = entrada.nextInt();
    System.out.println("Idade da terceira pessoa: ");
    idade_p3 = entrada.nextInt();
    
    //processamento
    media_idade = (idade_p1 + idade_p2 + idade_p3)/3;

    //retorno do valor calculado
    // highlight-next-line
    return(media_idade);

}  

public static void main(String[] args){
    
    //variáveis
    real idade_media;
    
    //chamada ao módulo
    // highlight-next-line
    idade_media = idadeMediaTresPessoas();

    //saida
    System.out.printf("A idade média é %f\n", idade_media);
}
  ```

Java é uma linguagem de programação **orientada a objetos**. Aqui desenvolvemos uma função, porém no contexto de orientação a objetos esta atividade é chamada de **método**. Por ora utilizaremos o termo função e método como sinônimos, porém tenha em mente que estes possuem funcionalidades distintas, e suas diferenças e características serão abordadas futuramente.


  </TabItem>
  <TabItem value="python" label="Python">

  ```python
  def idadeMediaTresPessoas():
    idade_p1 = int(input("Idade da primeira pessoa: "))
    idade_p2 = int(input("Idade da segunda pessoa: "))
    idade_p3 = int(input("Idade da terceira pessoa: "))

    media_idade = (idade_p1 + idade_p2 + idade_p3)/3
    return media_idade

 idade_media = idadeMediaTresPessoas()
 print(f"A idade média é de {idade_media}")
  ```

  </TabItem>
</Tabs>

Observe que nas funções existe o **retorno** do valor calculado. Essa é uma das principais características das funções.


**Exercício**  

Considere um algoritmo que pergunta a altura e o peso de uma pessoa, e a partir disso calcula e retorna seu índice de massa corporal (IMC), de acordo com a seguinte fórmula:
$$
imc = \frac{peso}{altura^2}
$$


# Parâmetros

Uma das possibilidades com os procedimentos e as funções é a passagem de parâmetros. Os parâmetros consistem nos conteúdos a serem passados para as variáveis que estão dentro das funções.

O uso dos parâmetros permite que o conteúdo da função seja realizado de acordo com os conteúdos das variáveis a ela passados.

**Exemplo**
- Desenvolva uma função que retorna verdadeiro se o valor passado por parâmetro for par.

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ```c
  inicio
    //módulos
    modulo par(inteiro: numero)
        se(mod(numero,2) = 0)
        então
            retorne verdadeiro;
        senão
            retorne falso;
        fimse;
    fimmodulo;
  
    //variáveis
    inteiro: x;

    //entrada
    escreva("Entre com um número: ");
    leia(x);

    //processamento e saída
    se(par(x))
    então
        escreva(x, "é par.");
    senão
        escreva(x, "é ímpar.");
    fimse.
  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ```javascript
    //módulos
    public static boolean par(int numero){
        if(numero % 2 == 0){
            return true;
        }else{
            return false;
        }
    }

    //main
    public static void main(String[] args){
        //variáveis
        int: x;
        Scanner entrada = new Scanner(System.in);

        //entrada
        System.out.println("Entre com um número: ");
        leia(x);
        entrada.close();

        //processamento e saída
        if(par(x)){
            System.out.printf("%d é par.\n");
        }else{
            System.out.printf("%d é ímpar.\n");
        }
    }
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
    #módulos
    def par(numero):
        if numero%2 == 0:
            return True
        else:
            return False;
  
    #entrada
    x = int(input("Entre com um número: "))

    #processamento e saída
    if par(x):
        print(f"{x} é par.");
    else:
        print(f"{x} é ímpar.");
  ```

  </TabItem>
</Tabs>


**Exemplo**
- Desenvolva uma função que retorna a soma de todos os números ímpares em um intervalo.

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ```c
  inicio
    //módulos
    modulo par(inteiro: numero)
        se(mod(numero,2) = 0)
            então
                retorne verdadeiro;
            senão
                retorne falso;
        fimse;
    fimmodulo;

    modulo impar(inteiro: numero)
        retorne(não par(numero));
    fimmodulo;

    modulo somaImparesIntervalo(inteiro: inicio, inteiro: fim)
        inteiro: soma ← 0, i;
        para i de inicio até fim passo 1 faça
            se(impar(i))
            então
                soma ← soma + i;
            fimse;
        fimpara;
        retorne soma;
    fimmodulo.

    //variáveis
    inteiro: ini, fim, soma;

    //entrada
    escreva("Entre com os valores de início e fim: ");
    leia(ini);
    leia(fim);

    //processamento
    soma ← somaImparesIntervalo(ini, fim);

    //saída
    escreva("A soma dos valores ímpares no intervalo [", ini, ",", fim, "] é ", soma);
  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ```javascript
    //módulos
    public static boolean par(int numero){
        if(numero%2 == 0){
            return true;
        }else{
            return false;
        }
    }

    public static boolean impar(int numero){
        return !par(numero);
    }

    public static int somaImparesIntervalo(int inicio, int fim){
        int soma = 0, i;
        for(i=inicio; i<=fim; i++)
            if(impar(i)){
                soma = soma + i;
            }
        return soma;
    }

    //variáveis
    int ini, fim, soma;
    Scanner entrada = new Scanner(System.in);

    //entrada
    System.out.println("Entre com os valores de início e fim: ");
    ini = entrada.nextInt();
    fim = entrada.nextInt();
    entrada.close();

    //processamento
    soma = somaImparesIntervalo(ini, fim);

    //saída
    System.out.printf("A soma dos valores ímpares no intervalo [ %d , %d é %d\n", ini, fim, soma);
  fim.
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
    #módulos
    def par(numero)
        if numero % 2 == 0:
            return True
        else:
            return False
        
    def impar(numero):
        return not par(numero)

    def somaImparesIntervalo(inicio, fim):
        soma = 0
        for i in range(ini, fim+1):
            if impar(i):
                soma = soma + i
        return soma

    
    #entrada
    print("Entre com os valores de início e fim: ");
    ini = int(input())
    fim = int(input())

    #processamento
    soma ← somaImparesIntervalo(ini, fim)

    #saída
    prinf(f"A soma dos valores ímpares no intervalo [{ini},{fim}] é {soma}")
  ```

  </TabItem>
</Tabs>

**Exercícios**  
- Desenvolva funções que realizem os seguinte cálculos:
    - O maior valor entre duas variáveis do tipo inteiro;
    - O menor valor entre duas variáveis do tipo inteiro;
    - A soma de todos os números impares em um intervalo, em que o usuário pode digitar o início e o fim do intervalo em qualquer ordem;
    - O Mínimo Múltiplo Comum (MMC) entre dois valores;
    - O Máximo Divisor Comum (MDC) entre dois valores.


# Escopo de variáveis

Chamamos de **escopo** ao espaço em que determinada variável pode ser utilizada. Comumente, o escopo pode ser **local** ou **global**.

## Variáveis locais

Uma variável é considerada **local** quando esta existe apenas em um módulo específico.

**Exemplo**
<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ```c
  inicio
    modulo media3Valores(inteiro: a, real: b, real: c)
        //variáveis
        inteiro soma;
        real media;

        //processamento
        soma = a+b+c;
        media = soma/3;

        //retorno
        retorne media;
    fimmodulo;

    //variáveis e entrada
    inteiro: x, y, z;
    escreva("Entre com três valores: ");
    leia(x); leia(y); leia(z);

    escreva("A média é ", media3Valores(x,y,z))

  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ```javascript
  public static float media3Valores(int a, int b, int c){
    //variáveis
    int soma;
    float media;

    //processamento
    soma = a+b+c;
    media = soma/3;

    //retorno
    return media;
  }

  public static void main(String[] args){
    //variáveis e entrada
    int x,y,z;
    System.out.println("Entre com três valores: ");
    Scanner entrada = new Scanner(System.in);
    x = entrada.nextInt(); y = entrada.nextInt(); z = entrada.nextInt();

    //chamada ao método e saída
    System.out.printf("A média é %f\n", media3Valores(x,y,z));
  }
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
    def media3Valores(a, b, c)
        #processamento
        soma = a+b+c
        media = soma/3

        #retorno
        return media

    #variáveis e entrada
    print("Entre com três valores: ")
    x, y, z = int(input()), int(input()), int(input())

    print("A média é ", media3Valores(x,y,z))
  ```

  </TabItem>
</Tabs>

Observe que as variáveis `a`, `b`, `c`, `soma` e `media` existem **apenas** dentro do módulo `media3valores`. Com isto, dizemos que o **escopo** destas variáveis é **local** à função `media3Valores`.

Acessar estas variáveis fora de seu escopo ocasiona em um erro.

**Exemplo**
<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ```c
  inicio
    modulo media3Valores(inteiro: a, real: b, real: c)
        //variáveis
        inteiro soma;
        real media;

        //processamento
        soma = a+b+c;
        media = soma/3;

        //retorno
        retorne media;
    fimmodulo;

    //variáveis
    inteiro: x, y, z;
    escreva("Entre com três valores: ");
    leia(x); leia(y); leia(z);

    escreva("A média é ", media3Valores(x,y,z));

    //erro aqui
    //highlight-next-line
    escreva("A soma dos valores é ", soma);//soma não existe neste escopo

  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ```javascript
  public static float media3Valores(int a, int b, int c){
    //variáveis
    int soma;
    float media;

    //processamento
    soma = a+b+c;
    media = soma/3;

    //retorno
    return media;
  }

  public static void main(String[] args){
    //variáveis e entrada
    int x,y,z;
    System.out.println("Entre com três valores: ");
    Scanner entrada = new Scanner(System.in);
    x = entrada.nextInt(); y = entrada.nextInt(); z = entrada.nextInt();

    //chamada ao método e saída
    System.out.printf("A média é %f\n", media3Valores(x,y,z));

    //erro aqui
    //highlight-next-line
    System.out.printf("A soma dos valores é ", soma);//soma não existe neste escopo
  }
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
  print("Olá Mundo")
  ```

  </TabItem>
</Tabs>

Em escopos diferentes, variáveis locais podem utilizar os mesmos nomes. Como estão em escopos diferentes são **variáveis diferentes**.

**Exemplo**
<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ```c
  inicio
    modulo mostraValorMaisDez(inteiro: x)
        inteiro: v; //variável v local à função
        //highlight-next-line
        v = x+10;  //um valor é atribuído a v dentro da função
        escreva("V dentro do módulo: ", v);
    fimmodulo;

    //variáveis
    inteiro: v; //variável v local ao código principal
    //highlight-next-line
    v = 10; //um valor é atribuído a v fora da função
    escreva("V fora do módulo: ", v); //mostra o valor 10
    mostraValorMaisDez(v);            //mostra o valor 20
    escreva("V fora do módulo: ", v); //mostra o valor 10. O valor original foi mantido.

  fim.
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ```javascript
    public static void mostraValorMaisDez(int x){
        int v; //variável v local à função
        //highlight-next-line
        v = x+10;  //um valor é atribuído a v dentro da função
        System.out.printf("V dentro do módulo: %d\n", v);
    }

    public static void main(String[] args){
        //variáveis
        int v; //variável v local ao código principal
        //highlight-next-line
        v = 10; //um valor é atribuído a v fora da função
        System.out.printf("V fora do módulo: %d\n", v); //mostra o valor 10
        mostraValorMaisDez(v);                          //mostra o valor 20
        System.out.printf("V fora do módulo: %d\n", v); //mostra o valor 10. O valor original foi mantido.
    }
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
    def mostraValorMaisDez(x):
        #highlight-next-line
        v = x+10;  //um valor é atribuído a v dentro da função
        print("V dentro do módulo: ", v)
    
    #highlight-next-line
    v = 10; #um valor é atribuído a v fora da função
    print("V fora do módulo:", v) #mostra o valor 10
    mostraValorMaisDez(v)         #mostra o valor 20
    print("V fora do módulo:", v) #mostra o valor 10. O valor original foi mantido.
  ```

  </TabItem>
</Tabs>


## Variáveis globais

Aa variáveis **globais** são aquelas que podem ser acessadas por todos, e portanto, são **compartilhadas** entre todos os módulos.

Para definir uma variável como global, basta declará-la fora do módulo.

<Tabs groupId='language'>
  <TabItem value="pseudocodigo" label="Pseudocódigo" default>

  ```c
  escreva("Olá Mundo");
  ```

  </TabItem>
  <TabItem value="java" label="Java">

  ```javascript
  System.out.println("Olá Mundo");
  ```

  </TabItem>
  <TabItem value="python" label="Python">

  ```python
  print("Olá Mundo")
  ```

  </TabItem>
</Tabs>